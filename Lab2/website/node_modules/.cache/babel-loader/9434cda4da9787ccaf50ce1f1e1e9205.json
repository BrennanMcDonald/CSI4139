{"ast":null,"code":"var http = require('http'),\n    https = require('https'),\n    common = require('../common');\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, socket, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n/*\n * Websockets Passes\n *\n */\n\n\nmodule.exports = {\n  /**\n   * WebSocket requests must have the `GET` method and\n   * the `upgrade:websocket` header\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   *\n   * @api private\n   */\n  checkMethodAndHeader: function checkMethodAndHeader(req, socket) {\n    if (req.method !== 'GET' || !req.headers.upgrade) {\n      socket.destroy();\n      return true;\n    }\n\n    if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n      socket.destroy();\n      return true;\n    }\n  },\n\n  /**\n   * Sets `x-forwarded-*` headers if specified in config.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n  XHeaders: function XHeaders(req, socket, options) {\n    if (!options.xfwd) return;\n    var values = {\n      for: req.connection.remoteAddress || req.socket.remoteAddress,\n      port: common.getPort(req),\n      proto: common.hasEncryptedConnection(req) ? 'wss' : 'ws'\n    };\n    ['for', 'port', 'proto'].forEach(function (header) {\n      req.headers['x-forwarded-' + header] = (req.headers['x-forwarded-' + header] || '') + (req.headers['x-forwarded-' + header] ? ',' : '') + values[header];\n    });\n  },\n\n  /**\n   * Does the actual proxying. Make the request and upgrade it\n   * send the Switching Protocols request and pipe the sockets.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n  stream: function stream(req, socket, options, head, server, clb) {\n    var createHttpHeader = function (line, headers) {\n      return Object.keys(headers).reduce(function (head, key) {\n        var value = headers[key];\n\n        if (!Array.isArray(value)) {\n          head.push(key + ': ' + value);\n          return head;\n        }\n\n        for (var i = 0; i < value.length; i++) {\n          head.push(key + ': ' + value[i]);\n        }\n\n        return head;\n      }, [line]).join('\\r\\n') + '\\r\\n\\r\\n';\n    };\n\n    common.setupSocket(socket);\n    if (head && head.length) socket.unshift(head);\n    var proxyReq = (common.isSSL.test(options.target.protocol) ? https : http).request(common.setupOutgoing(options.ssl || {}, options, req)); // Enable developers to modify the proxyReq before headers are sent\n\n    if (server) {\n      server.emit('proxyReqWs', proxyReq, req, socket, options, head);\n    } // Error Handler\n\n\n    proxyReq.on('error', onOutgoingError);\n    proxyReq.on('response', function (res) {\n      // if upgrade event isn't going to happen, close the socket\n      if (!res.upgrade) {\n        socket.write(createHttpHeader('HTTP/' + res.httpVersion + ' ' + res.statusCode + ' ' + res.statusMessage, res.headers));\n        res.pipe(socket);\n      }\n    });\n    proxyReq.on('upgrade', function (proxyRes, proxySocket, proxyHead) {\n      proxySocket.on('error', onOutgoingError); // Allow us to listen when the websocket has completed\n\n      proxySocket.on('end', function () {\n        server.emit('close', proxyRes, proxySocket, proxyHead);\n      }); // The pipe below will end proxySocket if socket closes cleanly, but not\n      // if it errors (eg, vanishes from the net and starts returning\n      // EHOSTUNREACH). We need to do that explicitly.\n\n      socket.on('error', function () {\n        proxySocket.end();\n      });\n      common.setupSocket(proxySocket);\n      if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead); //\n      // Remark: Handle writing the headers to the socket when switching protocols\n      // Also handles when a header is an array\n      //\n\n      socket.write(createHttpHeader('HTTP/1.1 101 Switching Protocols', proxyRes.headers));\n      proxySocket.pipe(socket).pipe(proxySocket);\n      server.emit('open', proxySocket);\n      server.emit('proxySocket', proxySocket); //DEPRECATED.\n    });\n    return proxyReq.end(); // XXX: CHECK IF THIS IS THIS CORRECT\n\n    function onOutgoingError(err) {\n      if (clb) {\n        clb(err, req, socket);\n      } else {\n        server.emit('error', err, req, socket);\n      }\n\n      socket.end();\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}