{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst httpProxy = require(\"http-proxy\");\n\nconst _ = require(\"lodash\");\n\nconst config_factory_1 = require(\"./config-factory\");\n\nconst contextMatcher = require(\"./context-matcher\");\n\nconst handlers = require(\"./handlers\");\n\nconst logger_1 = require(\"./logger\");\n\nconst PathRewriter = require(\"./path-rewriter\");\n\nconst Router = require(\"./router\");\n\nclass HttpProxyMiddleware {\n  constructor(context, opts) {\n    this.logger = logger_1.getInstance();\n    this.wsInternalSubscribed = false; // https://github.com/Microsoft/TypeScript/wiki/'this'-in-TypeScript#red-flags-for-this\n\n    this.middleware = (req, res, next) => __awaiter(this, void 0, void 0, function* () {\n      if (this.shouldProxy(this.config.context, req)) {\n        const activeProxyOptions = this.prepareProxyRequest(req);\n        this.proxy.web(req, res, activeProxyOptions);\n      } else {\n        next();\n      }\n\n      if (this.proxyOptions.ws === true) {\n        // use initial request to access the server object to subscribe to http upgrade event\n        this.catchUpgradeRequest(req.connection.server);\n      }\n    });\n\n    this.catchUpgradeRequest = server => {\n      if (!this.wsInternalSubscribed) {\n        server.on('upgrade', this.handleUpgrade); // prevent duplicate upgrade handling;\n        // in case external upgrade is also configured\n\n        this.wsInternalSubscribed = true;\n      }\n    };\n\n    this.handleUpgrade = (req, socket, head) => {\n      if (this.shouldProxy(this.config.context, req)) {\n        const activeProxyOptions = this.prepareProxyRequest(req);\n        this.proxy.ws(req, socket, head, activeProxyOptions);\n        this.logger.info('[HPM] Upgrading to WebSocket');\n      }\n    };\n    /**\n     * Determine whether request should be proxied.\n     *\n     * @private\n     * @param  {String} context [description]\n     * @param  {Object} req     [description]\n     * @return {Boolean}\n     */\n\n\n    this.shouldProxy = (context, req) => {\n      const path = req.originalUrl || req.url;\n      return contextMatcher.match(context, path, req);\n    };\n    /**\n     * Apply option.router and option.pathRewrite\n     * Order matters:\n     *    Router uses original path for routing;\n     *    NOT the modified path, after it has been rewritten by pathRewrite\n     * @param {Object} req\n     * @return {Object} proxy options\n     */\n\n\n    this.prepareProxyRequest = req => {\n      // https://github.com/chimurai/http-proxy-middleware/issues/17\n      // https://github.com/chimurai/http-proxy-middleware/issues/94\n      req.url = req.originalUrl || req.url; // store uri before it gets rewritten for logging\n\n      const originalPath = req.url;\n\n      const newProxyOptions = _.assign({}, this.proxyOptions); // Apply in order:\n      // 1. option.router\n      // 2. option.pathRewrite\n\n\n      this.applyRouter(req, newProxyOptions);\n      this.applyPathRewrite(req, this.pathRewriter); // debug logging for both http(s) and websockets\n\n      if (this.proxyOptions.logLevel === 'debug') {\n        const arrow = logger_1.getArrow(originalPath, req.url, this.proxyOptions.target, newProxyOptions.target);\n        this.logger.debug('[HPM] %s %s %s %s', req.method, originalPath, arrow, newProxyOptions.target);\n      }\n\n      return newProxyOptions;\n    }; // Modify option.target when router present.\n\n\n    this.applyRouter = (req, options) => {\n      let newTarget;\n\n      if (options.router) {\n        newTarget = Router.getTarget(req, options);\n\n        if (newTarget) {\n          this.logger.debug('[HPM] Router new target: %s -> \"%s\"', options.target, newTarget);\n          options.target = newTarget;\n        }\n      }\n    }; // rewrite path\n\n\n    this.applyPathRewrite = (req, pathRewriter) => {\n      if (pathRewriter) {\n        const path = pathRewriter(req.url, req);\n\n        if (typeof path === 'string') {\n          req.url = path;\n        } else {\n          this.logger.info('[HPM] pathRewrite: No rewritten path found. (%s)', req.url);\n        }\n      }\n    };\n\n    this.logError = (err, req, res) => {\n      const hostname = req.headers && req.headers.host || req.hostname || req.host; // (websocket) || (node0.10 || node 4/5)\n\n      const target = this.proxyOptions.target.host || this.proxyOptions.target;\n      const errorMessage = '[HPM] Error occurred while trying to proxy request %s from %s to %s (%s) (%s)';\n      const errReference = 'https://nodejs.org/api/errors.html#errors_common_system_errors'; // link to Node Common Systems Errors page\n\n      this.logger.error(errorMessage, req.url, hostname, target, err.code || err, errReference);\n    };\n\n    this.config = config_factory_1.createConfig(context, opts);\n    this.proxyOptions = this.config.options; // create proxy\n\n    this.proxy = httpProxy.createProxyServer({});\n    this.logger.info(\"[HPM] Proxy created: \".concat(this.config.context, \"  -> \").concat(this.proxyOptions.target));\n    this.pathRewriter = PathRewriter.createPathRewriter(this.proxyOptions.pathRewrite); // returns undefined when \"pathRewrite\" is not provided\n    // attach handler to http-proxy events\n\n    handlers.init(this.proxy, this.proxyOptions); // log errors for debug purpose\n\n    this.proxy.on('error', this.logError); // https://github.com/chimurai/http-proxy-middleware/issues/19\n    // expose function to upgrade externally\n\n    this.middleware.upgrade = (req, socket, head) => {\n      if (!this.wsInternalSubscribed) {\n        this.handleUpgrade(req, socket, head);\n      }\n    };\n  }\n\n}\n\nexports.HttpProxyMiddleware = HttpProxyMiddleware;","map":null,"metadata":{},"sourceType":"script"}