{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst _ = require(\"lodash\");\n\nconst util = require(\"util\");\n\nlet loggerInstance;\nconst defaultProvider = {\n  // tslint:disable: no-console\n  log: console.log,\n  debug: console.log,\n  info: console.info,\n  warn: console.warn,\n  error: console.error\n}; // log level 'weight'\n\nvar LEVELS;\n\n(function (LEVELS) {\n  LEVELS[LEVELS[\"debug\"] = 10] = \"debug\";\n  LEVELS[LEVELS[\"info\"] = 20] = \"info\";\n  LEVELS[LEVELS[\"warn\"] = 30] = \"warn\";\n  LEVELS[LEVELS[\"error\"] = 50] = \"error\";\n  LEVELS[LEVELS[\"silent\"] = 80] = \"silent\";\n})(LEVELS || (LEVELS = {}));\n\nfunction getInstance() {\n  if (!loggerInstance) {\n    loggerInstance = new Logger();\n  }\n\n  return loggerInstance;\n}\n\nexports.getInstance = getInstance;\n\nclass Logger {\n  constructor() {\n    this.setLevel('info');\n    this.setProvider(() => defaultProvider);\n  } // log will log messages, regardless of logLevels\n\n\n  log() {\n    this.provider.log(this._interpolate.apply(null, arguments));\n  }\n\n  debug() {\n    if (this._showLevel('debug')) {\n      this.provider.debug(this._interpolate.apply(null, arguments));\n    }\n  }\n\n  info() {\n    if (this._showLevel('info')) {\n      this.provider.info(this._interpolate.apply(null, arguments));\n    }\n  }\n\n  warn() {\n    if (this._showLevel('warn')) {\n      this.provider.warn(this._interpolate.apply(null, arguments));\n    }\n  }\n\n  error() {\n    if (this._showLevel('error')) {\n      this.provider.error(this._interpolate.apply(null, arguments));\n    }\n  }\n\n  setLevel(v) {\n    if (this.isValidLevel(v)) {\n      this.logLevel = v;\n    }\n  }\n\n  setProvider(fn) {\n    if (fn && this.isValidProvider(fn)) {\n      this.provider = fn(defaultProvider);\n    }\n  }\n\n  isValidProvider(fnProvider) {\n    const result = true;\n\n    if (fnProvider && !_.isFunction(fnProvider)) {\n      throw new Error('[HPM] Log provider config error. Expecting a function.');\n    }\n\n    return result;\n  }\n\n  isValidLevel(levelName) {\n    const validLevels = Object.keys(LEVELS);\n    const isValid = validLevels.includes(levelName);\n\n    if (!isValid) {\n      throw new Error('[HPM] Log level error. Invalid logLevel.');\n    }\n\n    return isValid;\n  }\n  /**\n   * Decide to log or not to log, based on the log levels 'weight'\n   * @param  {String}  showLevel [debug, info, warn, error, silent]\n   * @return {Boolean}\n   */\n\n\n  _showLevel(showLevel) {\n    let result = false;\n    const currentLogLevel = LEVELS[this.logLevel];\n\n    if (currentLogLevel && currentLogLevel <= LEVELS[showLevel]) {\n      result = true;\n    }\n\n    return result;\n  } // make sure logged messages and its data are return interpolated\n  // make it possible for additional log data, such date/time or custom prefix.\n\n\n  _interpolate() {\n    const fn = _.spread(util.format);\n\n    const result = fn(_.slice(arguments));\n    return result;\n  }\n\n}\n/**\n * -> normal proxy\n * => router\n * ~> pathRewrite\n * ≈> router + pathRewrite\n *\n * @param  {String} originalPath\n * @param  {String} newPath\n * @param  {String} originalTarget\n * @param  {String} newTarget\n * @return {String}\n */\n\n\nfunction getArrow(originalPath, newPath, originalTarget, newTarget) {\n  const arrow = ['>'];\n  const isNewTarget = originalTarget !== newTarget; // router\n\n  const isNewPath = originalPath !== newPath; // pathRewrite\n\n  if (isNewPath && !isNewTarget) {\n    arrow.unshift('~');\n  } else if (!isNewPath && isNewTarget) {\n    arrow.unshift('=');\n  } else if (isNewPath && isNewTarget) {\n    arrow.unshift('≈');\n  } else {\n    arrow.unshift('-');\n  }\n\n  return arrow.join('');\n}\n\nexports.getArrow = getArrow;","map":null,"metadata":{},"sourceType":"script"}