{"ast":null,"code":"var httpProxy = module.exports,\n    extend = require('util')._extend,\n    parse_url = require('url').parse,\n    EE3 = require('eventemitter3'),\n    http = require('http'),\n    https = require('https'),\n    web = require('./passes/web-incoming'),\n    ws = require('./passes/ws-incoming');\n\nhttpProxy.Server = ProxyServer;\n/**\n * Returns a function that creates the loader for\n * either `ws` or `web`'s  passes.\n *\n * Examples:\n *\n *    httpProxy.createRightProxy('ws')\n *    // => [Function]\n *\n * @param {String} Type Either 'ws' or 'web'\n *Â \n * @return {Function} Loader Function that when called returns an iterator for the right passes\n *\n * @api private\n */\n\nfunction createRightProxy(type) {\n  return function (options) {\n    return function (req, res\n    /*, [head], [opts] */\n    ) {\n      var passes = type === 'ws' ? this.wsPasses : this.webPasses,\n          args = [].slice.call(arguments),\n          cntr = args.length - 1,\n          head,\n          cbl;\n      /* optional args parse begin */\n\n      if (typeof args[cntr] === 'function') {\n        cbl = args[cntr];\n        cntr--;\n      }\n\n      var requestOptions = options;\n\n      if (!(args[cntr] instanceof Buffer) && args[cntr] !== res) {\n        //Copy global options\n        requestOptions = extend({}, options); //Overwrite with request options\n\n        extend(requestOptions, args[cntr]);\n        cntr--;\n      }\n\n      if (args[cntr] instanceof Buffer) {\n        head = args[cntr];\n      }\n      /* optional args parse end */\n\n\n      ['target', 'forward'].forEach(function (e) {\n        if (typeof requestOptions[e] === 'string') requestOptions[e] = parse_url(requestOptions[e]);\n      });\n\n      if (!requestOptions.target && !requestOptions.forward) {\n        return this.emit('error', new Error('Must provide a proper URL as target'));\n      }\n\n      for (var i = 0; i < passes.length; i++) {\n        /**\n         * Call of passes functions\n         * pass(req, res, options, head)\n         *\n         * In WebSockets case the `res` variable\n         * refer to the connection socket\n         * pass(req, socket, options, head)\n         */\n        if (passes[i](req, res, requestOptions, head, this, cbl)) {\n          // passes can return a truthy value to halt the loop\n          break;\n        }\n      }\n    };\n  };\n}\n\nhttpProxy.createRightProxy = createRightProxy;\n\nfunction ProxyServer(options) {\n  EE3.call(this);\n  options = options || {};\n  options.prependPath = options.prependPath === false ? false : true;\n  this.web = this.proxyRequest = createRightProxy('web')(options);\n  this.ws = this.proxyWebsocketRequest = createRightProxy('ws')(options);\n  this.options = options;\n  this.webPasses = Object.keys(web).map(function (pass) {\n    return web[pass];\n  });\n  this.wsPasses = Object.keys(ws).map(function (pass) {\n    return ws[pass];\n  });\n  this.on('error', this.onError, this);\n}\n\nrequire('util').inherits(ProxyServer, EE3);\n\nProxyServer.prototype.onError = function (err) {\n  //\n  // Remark: Replicate node core behavior using EE3\n  // so we force people to handle their own errors\n  //\n  if (this.listeners('error').length === 1) {\n    throw err;\n  }\n};\n\nProxyServer.prototype.listen = function (port, hostname) {\n  var self = this,\n      closure = function (req, res) {\n    self.web(req, res);\n  };\n\n  this._server = this.options.ssl ? https.createServer(this.options.ssl, closure) : http.createServer(closure);\n\n  if (this.options.ws) {\n    this._server.on('upgrade', function (req, socket, head) {\n      self.ws(req, socket, head);\n    });\n  }\n\n  this._server.listen(port, hostname);\n\n  return this;\n};\n\nProxyServer.prototype.close = function (callback) {\n  var self = this;\n\n  if (this._server) {\n    this._server.close(done);\n  } // Wrap callback to nullify server after all open connections are closed.\n\n\n  function done() {\n    self._server = null;\n\n    if (callback) {\n      callback.apply(null, arguments);\n    }\n  }\n\n  ;\n};\n\nProxyServer.prototype.before = function (type, passName, callback) {\n  if (type !== 'ws' && type !== 'web') {\n    throw new Error('type must be `web` or `ws`');\n  }\n\n  var passes = type === 'ws' ? this.wsPasses : this.webPasses,\n      i = false;\n  passes.forEach(function (v, idx) {\n    if (v.name === passName) i = idx;\n  });\n  if (i === false) throw new Error('No such pass');\n  passes.splice(i, 0, callback);\n};\n\nProxyServer.prototype.after = function (type, passName, callback) {\n  if (type !== 'ws' && type !== 'web') {\n    throw new Error('type must be `web` or `ws`');\n  }\n\n  var passes = type === 'ws' ? this.wsPasses : this.webPasses,\n      i = false;\n  passes.forEach(function (v, idx) {\n    if (v.name === passName) i = idx;\n  });\n  if (i === false) throw new Error('No such pass');\n  passes.splice(i++, 0, callback);\n};","map":null,"metadata":{},"sourceType":"script"}